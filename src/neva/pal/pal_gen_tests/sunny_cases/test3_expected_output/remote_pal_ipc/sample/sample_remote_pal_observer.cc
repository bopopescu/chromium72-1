// This file is generated by PAL generator, do not modify.
// To make changes, modify the source file:
// test3.json

#include "sample_remote_pal_observer.h"

#include "pal/ipc/sample_messages.h"
#include "pal/public/pal.h"
#include "pal/public/pal_factory.h"
#include "remote_pal_ipc/sample/sample_remote_pal_interface_ipc.h"

namespace content {

SampleRemotePalObserver::SampleRemotePalObserver(RenderFrame* render_frame)
    : RenderFrameObserver(render_frame) {}

void SampleRemotePalObserver::OnDestruct() {
  delete this;
}

bool SampleRemotePalObserver::OnMessageReceived(const IPC::Message& message) {
  bool handled = true;
  IPC_BEGIN_MESSAGE_MAP(SampleRemotePalObserver, message)
  IPC_MESSAGE_HANDLER(SampleMsg_ProcessDataDone, OnProcessDataDone)
  IPC_MESSAGE_HANDLER(SampleMsg_SampleUpdate, OnSampleUpdate)
  IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}

void SampleRemotePalObserver::OnProcessDataDone(int pal_async_callback_id,
                                                int error_code,
                                                std::string data) {
  using namespace pal;
  SampleRemotePalInterfaceIPC* interface =
      reinterpret_cast<SampleRemotePalInterfaceIPC*>(
          pal::GetInstance()->GetSampleInterface());

  if (interface == nullptr) {
    LOG(ERROR) << "No Remote PAL implemented for interface";
    return;
  }
  interface->NotifyProcessData(pal_async_callback_id, error_code, data);
}

void SampleRemotePalObserver::OnSampleUpdate(const std::string& value) {
  using namespace pal;
  SampleRemotePalInterfaceIPC* interface =
      reinterpret_cast<SampleRemotePalInterfaceIPC*>(
          pal::GetInstance()->GetSampleInterface());

  if (interface == nullptr) {
    LOG(ERROR) << "No Remote PAL implemented for interface";
    return;
  }
  interface->NotifySampleUpdate(routing_id(), value);
}

}  // namespace content
