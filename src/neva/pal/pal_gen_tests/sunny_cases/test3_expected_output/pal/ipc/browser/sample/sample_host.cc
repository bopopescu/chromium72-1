// This file is generated by PAL generator, do not modify.
// To make changes, modify the source file:
// test3.json

#include "pal/ipc/browser/sample/sample_host.h"

#include "base/bind.h"
#include "pal/ipc/sample_messages.h"
#include "pal/public/pal.h"
#include "pal/public/pal_factory.h"

namespace pal {

SampleHost::SampleHost()
    : content::BrowserMessageFilter(SampleMsgStart),
      route_ids_(),
      weak_ptr_factory_(this) {
  mSampleUpdateCallback =
      base::Bind(&SampleHost::SendSampleUpdate, weak_ptr_factory_.GetWeakPtr());
}

SampleHost::~SampleHost() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
}

// clang-format off
bool SampleHost::OnMessageReceived(const IPC::Message& message) {
  int routing_id = message.routing_id();
  bool handled = true;

  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(
      SampleHost, message, &routing_id)
    case SampleHostMsg_Unsubscribe::ID:
      route_ids_.erase(routing_id);
      break;
    case SampleHostMsg_Subscribe::ID:
      route_ids_.insert(routing_id);
      AddCallbacks();
      break;
    IPC_MESSAGE_HANDLER(SampleHostMsg_CallFunc, OnCallFunc)
    IPC_MESSAGE_HANDLER(SampleHostMsg_ProcessData, OnProcessData)
    IPC_MESSAGE_HANDLER(SampleHostMsg_SubscribeToEvent, OnSubscribeToEvent)
    IPC_MESSAGE_UNHANDLED(handled = false)
  IPC_END_MESSAGE_MAP()
  return handled;
}
// clang-format on

void SampleHost::OnCallFunc(int* routing_id,
                            std::string arg1,
                            std::string arg2) {
  SampleInterface* interface = pal::GetInstance()->GetSampleInterface();

  if (interface != NULL) {
    interface->CallFunc(arg1, arg2);
  } else {
    LOG(ERROR) << "Interface not available";
  }
}

void SampleHost::OnProcessDataDone(int routing_id,
                                   int pal_async_callback_id,
                                   int32_t callback_index,
                                   int error_code,
                                   const std::string& data) {
  Send(new SampleMsg_ProcessDataDone(routing_id, pal_async_callback_id,
                                     callback_index, error_code, data));
}

void SampleHost::OnProcessData(int* routing_id,
                               int pal_async_callback_id,
                               std::string data,
                               int32_t callback_index) {
  SampleInterface* interface = pal::GetInstance()->GetSampleInterface();

  if (interface != NULL) {
    interface->ProcessData(
        data, base::Bind(&SampleHost::OnProcessDataDone,
                         weak_ptr_factory_.GetWeakPtr(), *routing_id,
                         pal_async_callback_id, callback_index));
  } else {
    LOG(ERROR) << "Interface not available";
  }
}

void SampleHost::OnSubscribeToEvent(int* routing_id) {
  SampleInterface* interface = pal::GetInstance()->GetSampleInterface();

  if (interface != NULL) {
    interface->SubscribeToEvent();
  } else {
    LOG(ERROR) << "Interface not available";
  }
}

void SampleHost::AddCallbacks() {
  SampleInterface* interface = pal::GetInstance()->GetSampleInterface();
  if (!interface)
    return;
  if (!mSampleUpdateSubscription.get()) {
    mSampleUpdateSubscription = interface->AddCallback(mSampleUpdateCallback);
  }
}

void SampleHost::SendSampleUpdate(const std::string& value) {
  for (const int route_id : route_ids_) {
    Send(new SampleMsg_SampleUpdate(route_id, value));
  }
}

}  // namespace pal